# Garbage Collection
:raised_hand_with_fingers_splayed: Let's talk about the garbage

垃圾收集（回收），即释放掉一部分不需要的内存空间。这里有三个基本问题需要解决：
- 哪里需要进行垃圾回收？
- 何时进行回收？
- 怎样回收？

回答第一个问题，确定我们的**讨论范围**：

当下我们了解了 JVM 内存结构，这里有三块区域是线程私有的：**虚拟机栈**，**本地方法栈**和**程序计数器**。由于在创建线程时，分配给它们的空间大小
是确定的。它们的空间分配和释放由线程的生命周期决定，具有一种确定性。这意味着我们的关注点并不在这，而是在具有不确定性，动态变化的 **堆** 和 **方法区**。

## 对象已亡？
确定哪些对象已经死亡，是垃圾回收前须做的判断。

> 两种算法

:triangular_flag_on_post: Reference Counting——引用计数法

一种简单的算法：每个对象绑定一个计数器，当对象被引用（依赖）时，计数器计数加 1，被取消引用时，计数器减 1，计数器的计数为 0 时即判定该对象已死亡。这种算法在很多地方被
加以限制地使用，但是单纯的算法无法解决循环依赖的问题，导致多个对象永远不会被回收，在 Hotpot 中，这个算法并不被采用，可以通过编写循环依赖来验证[^1]

:triangular_flag_on_post: Reachability Analysis——可达性分析

可达，什么可达什么？选取了一组对象作为为 GC roots（根），某个对象直接或间接（沿着 Reference Chain）被 GC roots 对象引用，即为 GC roots 可达（able to reach）。
首先应该指明什么是 GC roots 的范围，或者哪些对象属于 GC roots：
- 虚拟机栈中被引用的对象，例如方法的局部变量，临时变量及参数等
- 方法区中的类静态变量引用的对象
- 本地方法栈中引用的对象
- 被 syn 锁住的对象
- JVM 内部引用，如基本数据类型的 Class对象，类加载器

GC roots 随着程序的运行会动态加入或删除一些对象。

不可达的对象，会被列入"待回收"的清单，但并不代表立马清除，更加详细的过程下方会进行讨论。

## 谈谈几种引用类型
早期的引用被简单的区分为"被引用"和"不被引用"，这种区分对于有些"食之无味弃之可惜"的对象无法做出决策:disappointed_relieved: 所以将引用类型再进行一次细分，以面对不同重要
程度的对象：

:one: 强引用：普通的引用，比如 ```Object o = new Object();``` o 为一个强引用。强引用永远不会被 GC 回收掉。

2️⃣ 软引用： 引用一些**有用但非必须**的对象，在 OOM 发生前，进行二次回收时会将软引用的对象回收掉。

3️⃣ 弱引用：引用一些**非必须**的对象，一次回收即可回收这些对象。

4️⃣ 虚引用：引用一些没有**实质性作用**的对象，无法通过虚引用得到对象，唯一作用是在其关联的对象在被回收时发个通知

## 对象生与死——回收过程
:triangular_flag_on_post: 经过可达性分析，判定为不可达，进行标记

:triangular_flag_on_post: 扫描到不可达标记对象，检查其是否==覆盖了 finalize() 方法 ==或== 未执行过 finalize() 方法 ==，若是，将其丢进一个叫 F-Queue 的队列，再进行扫描然后
执行其finalize() 方法——这将是对象最后的存活机会，如果其在重写的 finalize() 方法中，将自己与 GC roots Reference Chain 挂钩，就可避免被回收[^2]；若否,则直接回收。

注意：
- 这里将有一个优先级较低的 finalizer 线程依次执行 F-Queue 中对象的 finalize() 方法，但它不保证方法的是否被完全执行，这是为了避免线程陷入某个对象回收时的屏障而导致垃圾回收
阻塞
- finalize() 方法只能被执行一次。

可见，回收过程并不是直接将 对象 "判死"，而是"死缓"，即多次标记后"判死"。

## 垃圾回收算法

> 分代收集理论
> 
> 假说 1：弱分代假说，绝大多数对象都是"朝生夕死" 🏳️
> 
> 假说 2：强分代假说，熬过GC次数越多，生存机会越大，"大难不死，必有后福" 🙏
> 
> 假说 3：跨代引用假说，源于以上两种假说，跨代引用在同代中占极少数，跨代引用中的跨代终成同代，趋向同生共死！"有情人终成眷属" ♥️
> 
> 跨代引用时，比如强分代引用弱分代，进行 MinorGC 回收弱分代时，往往除了扫描弱分代进行可达性分析，还要扫描强分代，将被强分代引用的弱分代加入 GC roots
> 这样效率太低，可以在弱分代中维护一个 remember set 来记录哪些强分代引用弱分代，这样在 Minor GC 时可以不扫描 强分代。

> 注明：
> 
> 有两种 GC
> 
> 🚩 Patial GC
> 
>   🔴 Minoor/Young GC: 针对新生代
> 
>   🔴 Major/Old GC: 针对老年代
> 
>   🔴 Mixed GC：混合回收
> 
> 🚩 Full GC

算法：

🚩 标记-清除（Mark-Sweep）

🚩 标记-复制（Mark-Copy）

🚩 标记-整理（Mark-Compact）

[^1]:详细的代码见 [src/ReferenceCountingGC.java](../src/ReferenceCountingGC.java)
[^2]:[src/FinalizeEscapeGC.java](../src/FinalizeEscapeGC.java) 演示了一个对象的一次自救过程
