# Garbage Collection
:raised_hand_with_fingers_splayed: Let's talk about the garbage

垃圾收集（回收），即释放掉一部分不需要的内存空间。这里有三个基本问题需要解决：
- 哪里需要进行垃圾回收？
- 何时进行回收？
- 怎样回收？

回答第一个问题，确定我们的**讨论范围**：

当下我们了解了 JVM 内存结构，这里有三块区域是线程私有的：**虚拟机栈**，**本地方法栈**和**程序计数器**。由于在创建线程时，分配给它们的空间大小
是确定的。它们的空间分配和释放由线程的生命周期决定，具有一种确定性。这意味着我们的关注点并不在这，而是在具有不确定性，动态变化的 **堆** 和 **方法区**。

## 对象已亡？
确定哪些对象已经死亡，是垃圾回收前须做的判断。

> 两种算法

:triangular_flag_on_post: Reference Counting——引用计数法

一种简单的算法：每个对象绑定一个计数器，当对象被引用（依赖）时，计数器计数加 1，被取消引用时，计数器减 1，计数器的计数为 0 时即判定该对象已死亡。这种算法在很多地方被
加以限制地使用，但是单纯的算法无法解决循环依赖的问题，导致多个对象永远不会被回收，在 Hotpot 中，这个算法并不被采用，可以通过编写循环依赖来验证[^1]

:triangular_flag_on_post: Reachability Analysis——可达性分析

可达，什么可达什么？选取了一组对象作为为 GC roots（根），某个对象直接或间接（沿着 Reference Chain）被 GC roots 对象引用，即为 GC roots 可达（able to reach）。
首先应该指明什么是 GC roots 的范围，或者哪些对象属于 GC roots：
- 虚拟机栈中被引用的对象，例如方法的局部变量，临时变量及参数等
- 方法区中的类静态变量引用的对象
- 本地方法栈中引用的对象
- 被 syn 锁住的对象
- JVM 内部引用，如基本数据类型的 Class对象，类加载器

GC roots 随着程序的运行会动态加入或删除一些对象。

不可达的对象，会被列入"待回收"的清单，但并不代表立马清除，更加详细的过程下方会进行讨论。

## 谈谈几种引用类型
早期的引用被简单的区分为"被引用"和"不被引用"，这种区分对于有些"食之无味弃之可惜"的对象无法做出决策:disappointed_relieved: 所以将引用类型再进行一次细分，以面对不同重要
程度的对象：

:one: 强引用：普通的引用，比如 ```Object o = new Object();``` o 为一个强引用。强引用永远不会被 GC 回收掉。

2️⃣ 软引用： 引用一些**有用但非必须**的对象，在 OOM 发生前，进行二次回收时会将软引用的对象回收掉。

3️⃣ 弱引用：引用一些**非必须**的对象，一次回收即可回收这些对象。

4️⃣ 虚引用：引用一些没有**实质性作用**的对象，无法通过虚引用得到对象，唯一作用是在其关联的对象在被回收时发个通知

## 对象生与死——回收过程
:triangular_flag_on_post: 经过可达性分析，判定为不可达，进行标记

:triangular_flag_on_post: 扫描到不可达标记对象，检查其是否==覆盖了 finalize() 方法 ==或== 未执行过 finalize() 方法 ==，若是，将其丢进一个叫 F-Queue 的队列，再进行扫描然后
执行其finalize() 方法——这将是对象最后的存活机会，如果其在重写的 finalize() 方法中，将自己与 GC roots Reference Chain 挂钩，就可避免被回收[^2]；若否,则直接回收。

注意：
- 这里将有一个优先级较低的 finalizer 线程依次执行 F-Queue 中对象的 finalize() 方法，但它不保证方法的是否被完全执行，这是为了避免线程陷入某个对象回收时的屏障而导致垃圾回收
阻塞
- finalize() 方法只能被执行一次。

可见，回收过程并不是直接将 对象 "判死"，而是"死缓"，即多次标记后"判死"。

## 垃圾回收算法

> 分代收集理论
> 
> 假说 1：弱分代假说，绝大多数对象都是"朝生夕死" 🏳️
> 
> 假说 2：强分代假说，熬过GC次数越多，生存机会越大，"大难不死，必有后福" 🙏
> 
> 假说 3：跨代引用假说，源于以上两种假说，跨代引用在同代中占极少数，跨代引用中的跨代终成同代，趋向同生共死！"有情人终成眷属" ♥️
> 
> 跨代引用时，比如强分代引用弱分代，进行 MinorGC 回收弱分代时，往往除了扫描弱分代进行可达性分析，还要扫描强分代，将被强分代引用的弱分代加入 GC roots
> 这样效率太低，可以在弱分代中维护一个 remember set 来记录哪些强分代引用弱分代，这样在 Minor GC 时可以不扫描 强分代。

> 注明：
> 
> 有两种 GC
> 
> 🚩 Patial GC
> 
>   🔴 Minoor/Young GC: 针对新生代
> 
>   🔴 Major/Old GC: 针对老年代
> 
>   🔴 Mixed GC：混合回收
> 
> 🚩 Full GC

算法：

🚩 标记-清除（Mark-Sweep）

简单的算法：标记待回收的对象或者存活对象，移出待回收对象

缺点：1.内存碎片 2.回收的效率随存活对象增多而降低

![image](https://user-images.githubusercontent.com/59677595/174055756-01a8c7e5-93c9-45b6-bd22-7432f08958c5.png)

🚩 标记-复制（Mark-Copy）

“半区复制”算法，它将可用 内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着 的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。如果内存中多数对象都是存活的，这种算法将会产生大量的内存间复制的开销，但对于多数对象都是可回收的情况，算法需要复 制的就是占少数的存活对象，而且每次都是针对整个半区进行内存回收，分配内存时也就不用考虑有 空间碎片的复杂情况，只要移动堆顶指针，按顺序分配即可。这样实现简单，运行高效，不过其缺陷 也显而易见，这种复制回收算法的代价是将可用内存缩小为了原来的一半，空间浪费未免太多了一 点。

![image](https://user-images.githubusercontent.com/59677595/174056188-f14b74dc-dfc0-4bd3-b8f0-9f781fb5ce46.png)

> 在1989年，Andrew Appel针对具备“朝生夕灭”特点的对象，提出了一种更优化的半区复制分代策 略，现在称为“Appel式回收”。HotSpot虚拟机的Serial、ParNew等新生代收集器均采用了这种策略来设 计新生代的内存布局[1]。Appel式回收的具体做法是把新生代分为一块较大的Eden空间和两块较小的 Survivor空间，每次分配内存只使用Eden和其中一块Survivor。发生垃圾搜集时，将Eden和Survivor中仍 然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空
间。HotSpot虚拟机默认Eden和Survivor的大小比例是8∶1，也即每次新生代中可用内存空间为整个新 生代容量的90%（Eden的80%加上一个Survivor的10%），只有一个Survivor空间，即10%的新生代是会 被“浪费”的。当然，98%的对象可被回收仅仅是“普通场景”下测得的数据，任何人都没有办法百分百 保证每次回收都只有不多于10%的对象存活，因此Appel式回收还有一个充当罕见情况的“逃生门”的安 全设计，当Survivor空间不足以容纳一次 Minor GC 之后存活的对象时，就需要依赖其他内存区域（实 际上大多就是老年代）进行分配担保（Handle Promotion）。

🚩 标记-整理（Mark-Compact）

> 标记-复制算法在对象存活率较高时就要进行较多的复制操作，效率将会降低。更关键的是，如果 不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存 活的极端情况，所以在老年代一般不能直接选用这种算法。故有时采用 标记-整理 算法

![image](https://user-images.githubusercontent.com/59677595/174057746-595ffb2d-8239-4b7f-b3e4-583b4863e3d8.png)

很明显，标记-整理算法相比于标记-清除，前者动态地移动对象，移动对象的代价是暂停用户程序（即其他线程）——形象地称之为“stop the world”。当有大量存活对象时，代价是沉重的。
但是实践是根据具体情况权衡利弊的。下面引用 《深入JVM虚拟机》书上说明：

> 如果跟标记-清除算法那样完全不考虑移动和整理存活对象的话，弥散于堆中的存活对象导致的 空间碎片化问题就只能依赖更为复杂的内存分配器和内存访问器来解决。譬如通过“分区空闲分配链 表”来解决内存分配问题（计算机硬盘存储大文件就不要求物理连续的磁盘空间，能够在碎片化的硬盘上存储和访问就是通过硬盘分区表实现的）。内存的访问是用户程序最频繁的操作，甚至都没有之一，假如在这个环节上增加了额外的负担，势必会直接影响应用程序的吞吐量。 基于以上两点，是否移动对象都存在弊端，移动则内存回收时会更复杂，不移动则内存分配时会 更复杂。从垃圾收集的停顿时间来看，不移动对象停顿时间会更短，甚至可以不需要停顿，但是从整 个程序的吞吐量来看，移动对象会更划算。此语境中，吞吐量的实质是赋值器（Mutator，可以理解为 使用垃圾收集的用户程序，本书为便于理解，多数地方用“用户程序”或“用户线程”代替）与收集器的 效率总和。即使不移动对象会使得收集器的效率提升一些，但因内存分配和访问相比垃圾收集频率要 高得多，这部分的耗时增加，总吞吐量仍然是下降的。HotSpot虚拟机里面关注吞吐量的Parallel Scavenge收集器是基于标记-整理算法的，而关注延迟的CMS收集器则是基于标记-清除算法的，这也从侧面印证这点。 另外，还有一种“和稀泥式”解决方案可以不在内存分配和访问上增加太大额外负担，做法是让虚 拟机平时多数时间都采用标记-清除算法，暂时容忍内存碎片的存在，直到内存空间的碎片化程度已经 大到影响对象分配时，再采用标记-整理算法收集一次，以获得规整的内存空间。前面提到的基于标 记-清除算法的CMS收集器面临空间碎片过多时采用的就是这种处理办法。

[^1]:详细的代码见 [src/ReferenceCountingGC.java](../src/GC/ReferenceCountingGC.java)
[^2]:[src/FinalizeEscapeGC.java](../src/GC/FinalizeEscapeGC.java) 演示了一个对象的一次自救过程
