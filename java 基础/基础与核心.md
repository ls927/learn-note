## Java 语言基础&常识
#### Java 语言的特点？
- 面向对象（封装，继承和多态）
- 可移植 （基于JVM）
- 编译和解释共存（基于JVM中的JIT和解释器）
- 支持多线程（os）
- 支持网络编程（net）
- 可靠，稳定

#### JVM vs JRE vs JDK
🚩 JVM 是执行 java 字节码的虚拟机，是实现 java 可移植的关键。有很多实现版本，平常使用的是 Hotpot VM

🚩 JRE 是 java 运行环境，可运行已被编译的 java程序。包含了 JVM、java类库、java 命令和其他基础构件

🚩 JDK 是 java 开发工具，是功能齐全的 Java SDK。包含了 JRE 和编译器及其他工具。能够创建和编译 Java 程序

#### 什么是字节码？Java 采用字节码有什么好处？
能被 JVM 理解的代码即为字节码。字节码不面向特殊的机器，而只面向 JVM，采用字节码帮助 java 实现平台移植性。

java 程序运行如下图

![f1](https://javaguide.cn/assets/java%E7%A8%8B%E5%BA%8F%E8%BD%AC%E5%8F%98%E4%B8%BA%E6%9C%BA%E5%99%A8%E4%BB%A3%E7%A0%81%E7%9A%84%E8%BF%87%E7%A8%8B.3af43aee.png)

 JIT（just-in-time compilation） 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。

#### 为什么说 Java 是编译和解释共存的语言？
- 编译型语言：将程序语言一次编译成机器码，全部执行，执行速度快，开发效率慢。如 C，C++
- 解释型语言：将程序逐行解释成机器码并执行，执行速度慢，开发效率快。若 JavaScript，python
![f2](https://javaguide.cn/assets/%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80.9908e5e6.png)
JVM 类加载器首先加载**字节码文件**，然后通过**解释器逐行**解释执行，故称为编译和解释共存，这种方式的执行速度会相对比较慢

#### OracleJDK vs OpenJDK
OracleJDK 属于商用 JDK，而 OpenJDK 只是OracleJDK 的一个分支

#### Java 和 C++ 区别
- Java 只支持单重继承，C++支持多重继承，Java支持实现多接口
- Java 实现内存区域自动管理————垃圾回收机制，不用自己销毁对象，而C++只能手动释放内存
- Java 不支持通过指针直接访问内存，而C++ 支持
- C++ 支持操作符的重载，而 Java 不支持


## Java 基本语法
#### 字符型常量和字符串型常量的区别？
- 形式：字符型常量用单引号引起来的一个字符，而字符串型常量是用双引号引起来的 0~多个字符集合
- 含义：字符相当于一个整型值（ASCII），可以参与表达式运算，字符串常量代表一个地址值
- 大小：字符常量只占 2 个字节

#### 标识符 和 关键字 的区别？
为大量的类，变量，方法取名，简单来，说标识符就是一个名字。有一些标识符 Java 已经赋予其特殊意义
，这些就是关键字，如 protected,private,public,long,final等。

#### 自增自减运算符
**自增**和**赋值**注意顺序！

## 基本数据类型
#### 几种基本类型
🚩 数字类型: `int-4` `byte-1` `short-2` `double-8` `float-4` `long-8`

🚩 字符类型 `char-1`

🚩 布尔类型 `boolean-1Bit`

![image](https://user-images.githubusercontent.com/59677595/174266627-06c1d2be-11fb-4a24-84c7-a578ba199e53.png)

八种基本类型都有其包装类

#### 基本类与包装类的区别？
- 成员变量包装类不赋初值就为 null，而成员基本类型变量都有其默认值
- 包装类可用于泛型，基本类型不可
- 位置：包装类几乎所有实例始终被放在 堆 中
- 包装类占用空间较大

**为什么说是几乎所有对象实例呢？** 这是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存

#### 包装类型的缓存机制？
提升性能。对于 `Integer` `Byte` `Short` `Long` 这四种类型，默认（static）创建了数值 -128~127 的相应类型的缓存数据。`Character` 创建了数值在[0,127]范围的缓存数据,`Boolean`直接返回 `True`or`false`。

测试缓存：
```
Integer i1 = 40;
Integer i2 = new Integer(40);
System.out.println(i1==i2);  //false
```
输出为 false，是因为第一条代码发生装箱，也就是说等价于`Integer i1=Integer.valueOf(40)` 。因此，`i1` 直接使用的是缓存中的对象。而`Integer i2 = new Integer(40)`会直接创建新的对象。
因此，答案是 false

#### 自动装箱与拆箱
```
Integer i = 10; //装箱，等价于 Integer i = Integer.valueOf(10);
int n = i; //拆箱， 等价于 int n = i.intValue();
```
注意：如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。

## 方法
#### 静态方法为什么不能调用非静态成员？
结合 JVM 相关知识：时空角度
- 归属：静态方法属于类，再类加载的时候就给其分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化后才能通过实例对象访问。
- 先后：静态方法早于非静态成员存在，此时调用不存在的非静态成员是非法操作

#### 静态方法与实例方法有什么不同？
- 调用方式：静态方法通过`类名.方法名`，实例方法通过`对象.方法名`，调用静态方法不需要创建对象。
- 访问限制：静态方法只能访问静态成员，不能访问实例成员

#### 方法的重载与重写
- 重载：同样（同样的方法名）的方法根据输入的数据（参数）不同做出不同的处理
- 重写：基于继承，子类继承父类的相同方法，但做出一个有别父类的响应，就须重写（覆盖）方法，
如果父类用 `private/final/static` 修饰 方法时，子类无法重写。被`static`修饰的方法能够被再次声明。构造方法无法被重写。

![image](https://user-images.githubusercontent.com/59677595/174264178-bfa3d051-a7b4-4c70-a65f-6a4f19c7aa5a.png)

🚩 方法的重写要遵循“两同两小一大”（以下内容摘录自《疯狂 Java 讲义》，issue#892 ）：
- “两同”即方法名相同、形参列表相同；
- “两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；
- “一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。

#### 可变长参数？
可变长参数允许传递给方法不定数个参数，实质上被当作数组来处理了，在方法重载的时候优先匹配固定参数的。
```
public static void method(String... args){
  ...
}
//优先匹配
public static void method(String arg1,String arg2){
  ...
}
```


## 面向对象基础
#### 面向对象与面向过程的区别 ？
解决问题的方式不同：
- 面向过程：将解决问题的过程拆解为一个个方法，通过一个个方法的执行来解决问题
- 面向对象：对问题建模，先抽象出对象，然后用对象执行方法的方式解决问题

面向对象的程序，更易复用，维护和拓展。

#### 成员变量和局部变量的区别 ？
- 语法形式：成员变量是属于类的，局部变量是属于方法的。成员变量可以被 `public`,`private`,`static`等修饰符修饰，而局部变量不能。但是 `final` 可以用来修饰 成员变量和局部变量
- 存储方式: 在没有 `static` 修饰的情况下，成员变量是属于对象实例的，位于 堆 heap 中，局部变量属于方法，位于栈中
- 生存时间: 成员变量随对象的创建而存在，而局部变量随方法的调用而生成，方法调用结束而消亡
- 默认值: 成员变量有默认值，而局部变量没有

#### 创建一个对象用什么运算符？对象实体与对象引用有何不同？
new 运算符。对象实体是是对象的实例，是指储存在堆中的数据。而对象引用只是指向对象实例，只是地址值，它被存放在栈中。

#### 对象的相等和引用相等的区别
- 对象相等：比较的是内存中存放的内容是否相等
- 引用相等比较指向的内存地址是否相等

#### 类的构造方法是什么？它的作用？如果一个类没有声明构造方法，该程序能正常执行吗 ?
类的构造方法是一种特殊的方法，主要作用是完成对象的初始化工作。若没有声明构造方法，也可执行，因为自动有默认的不带参数的构造方法，如果手动声明无参或有参构造方法，将不会自动配置无参构造方法。

#### 构造方法有哪些特点？是否可被 override?
- 名字与类名相同。
- 没有返回值，不可用 void 声明
- 生成类的对象是自动执行，不需要调用

构造方法不能 override，但是可以重载。

#### 面向对象三大特征
三大特征：封装，继承，多态

**封装**：

封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象内部的信息。但是可以提供一些可被外界访问的方法来操作属性。

**继承**：

继承是使用已存在的类作为基础建立新类的技术（扩展技术），新类定义新的数据或功能，也可以使用父类的功能。值得说的是，子类必须继承父类的全部，不能选择性的继承。

- 子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，**只是拥有**。
- 子类可以有自己的属性和方法
- 子类可以用自己的方式重写 父类的方法

**多态** ：

顾名思义，表示一个对象具有多个状态，具体表现为父类的引用指向子类的实例。

特点：
- 对象类型与引用类型之间具有继承/实现的关系
- 引用类型变量发出的方法调用到底是哪个类中的方法，必须到程序运行期间才能确定
- **多态不能调用只有子类存在而父类不存在的方法**
- 如果子类重写了父类方法，真正在执行的是子类覆盖的方法，如果没有覆盖，将执行父类的方法

#### 接口和抽象类有什么共同点和区别？

🚩 共同点：
- 都不能直接实例化
- 都有抽象方法
- 都可以由默认实现的方法（java8 `default`）

🚩 不同点：
- 接口主要用于对类的行为进行约束，实现某个接口就具有了对应的行为，而抽象类主要用于代码复用，强调所属关系
- 一个类只能继承一个抽象类，但可以实现多个接口
- 接口中的成员变量只能用 `public static final`修饰，不能被修改且必须由初始值，而抽象类的成员变量默认为 `default`，可在子类被**重新定义**和赋值。

#### 深拷贝和浅拷贝的区别？什么是引用拷贝？
- 浅拷贝：在对象发生浅拷贝时，会在堆上创建新的对象（这不同于引用拷贝），如果这个对象类型成员变量有引用类型的话，浅拷贝只会直接复制内部对象的引用地址值，也就是说，拷贝对象和源对象共同拥有一个内部对象
- 深拷贝：在深拷贝时，会创建在堆中一个内部对象的副本，并用新的引用指向拷贝对象的内部对象，**即全部复制整个对象，包括内部对象**

实现方式：
- 浅拷贝：直接调用父类`Object`的`clone()`
- 深拷贝：需要实现 `Cloneable`接口，重写`clone()`，将内部对象也调用`clone()`复制一下即可

引用拷贝：就是两个不同的引用指向同一个对象

![image](https://user-images.githubusercontent.com/59677595/174634938-678625be-b4da-431e-8e3c-ebcdb16285af.png)

## Java 常见类

#### Object
这是一个特殊的类，是所有的父类。它主要提供了以下 11 个方法：
```
/**
 * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。
 */
public final native Class<?> getClass()
/**
 * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。
 */
public native int hashCode()
/**
 * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。
 */
public boolean equals(Object obj)
/**
 * naitive 方法，用于创建并返回当前对象的一份拷贝。
 */
protected native Object clone() throws CloneNotSupportedException
/**
 * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。
 */
public String toString()
/**
 * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。
 */
public final native void notify()
/**
 * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。
 */
public final native void notifyAll()
/**
 * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。
 */
public final native void wait(long timeout) throws InterruptedException
/**
 * 多了 nanos 参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 毫秒。。
 */
public final void wait(long timeout, int nanos) throws InterruptedException
/**
 * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念
 */
public final void wait() throws InterruptedException
/**
 * 实例被垃圾回收器回收的时候触发的操作
 */
protected void finalize() throws Throwable { }
```

**== 和 equals() 的区别**

- ``==`` 对于基本类型：比较的是值；对于引用类型：比较的是引用指向的地址值（对象的内存地址）。

> 因为 Java 只有值传递，所以，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。

- `equals()` 只能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。`equals()` 存在于 `Object`类中，而 `Object` 类是所有类的直接或间接的父类，因此所有的类都有 `equals()` 方法

`Object`类`equals()`方法：
```
public boolean equals(Object obj) {
     return (this == obj);
}
```
`equals()`两种使用情况：
- 类没有重写 `equals()`方法，等价于 "=="
- 有重写`equals()`方法，一般用来比较两个对象的属性是否相等
- `String` 的`equals()`方法又被重写：比较的是值。

`String`类`equals()`方法：

```
public boolean equals(Object anObject) {
    if (this == anObject) {
        return true;
    }
    if (anObject instanceof String) {
        String anotherString = (String)anObject;
        int n = value.length;
        if (n == anotherString.value.length) {
            char v1[] = value;
            char v2[] = anotherString.value;
            int i = 0;
            while (n-- != 0) {
                if (v1[i] != v2[i])
                    return false;
                i++;
            }
            return true;
        }
    }
    return false;
}
```

注：当创建 `String` 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 `String` 对象。

**hashCode()有什么用？**

获取 哈希码（int 整数，也称散列码），该方法是本地方法，由 C/C++ 实现，根据对象的内存地址值来计算得出。

**哈希码有什么作用？为什么要有哈希码？**

哈希码作用是确定该对象在哈希表中的索引位置，有助于提高哈希表键值对数据结构 存储和查找效率。
- 存储方面：存储不重复的元素（需要借助 hashCode() 和 equals() 来判断）
- 查询方面：最快能将效率提到 O(1),通过计算元素的哈希码得到键，快速检索出其对应的值（ contains() ） 

🚩 看看 HashSet 如何检查重复？—— 说明为什么有 hashCode

> 当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashCode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashCode 值作比较，如果没有相符的 hashCode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashCode 值的对象，这时会调用 equals() 方法来检查 hashCode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。

你会发现：`equals()` 和 `hashCode()` 都能判断对象是否相等，但是它们有所不同：
- 两个对象的`hashCode`值相等，这两个对象不一定相等（哈希冲突）
- 如果两个对象的`hashCode`值相等并且`equals()`方法也返回 `true`，我们才认为这两个对象相等。
- 如果两个对象的`hashCode`值不相等，我们就可以直接认为这两个对象不相等。

**为什么重写 equals 方法时，必须重写 hashCode 方法？**

⚠️ 注意：这是在你要将对象加入散列集中的前提下，必须做的事

在这个前提下，要**规定**两个对象相等，必须重写这两个方法（使得两个对象相等时，必须使 `hashCode`值相等并且`equals()`方法也返回 `true`）。如果只重写了 `equals()`，那么存在`equals()`判断相等的两个对象，它们 `hashCode` 不相等。那么散列集中出现 按**规定**相等的重复对象！（ 👀 具体测试代码见 ）

## String
#### String && StringBuilder && StringBuffer 的区别
🚩 可变性:

- String 是不可变的，原因是：它的内部实现
```
public final class String implements java.io.Serializable, Comparable<String>, CharSequence {
    private final char value[];
	//...
}
```
1. char 数组被 `private` 和 `final`修饰，且没有对外提供对该数组操作的方法

2. String 被声明为 `final`，不能被继承，避免了子类破环 String 不可变

- StringBuilder 与 StringBuffer 都继承于 AbstractStringBuilder ，在AbstractStringBuilder 中也是使用字符数组保存字符串，不过没有使用 final 和 private 关键字修饰，最关键的是这个 AbstractStringBuilder 类还提供了很多修改字符串的方法比如 append 方法
```
abstract class AbstractStringBuilder implements Appendable, CharSequence {
    char[] value;
    public AbstractStringBuilder append(String str) {
        if (str == null)
            return appendNull();
        int len = str.length();
        ensureCapacityInternal(count + len);
        str.getChars(0, len, value, count);
        count += len;
        return this;
    }
  	//...
}
```

🚩 线程安全性

`String` 中的对象是不可变的，也就可以理解为常量，线程安全。`AbstractStringBuilder` 是 `StringBuilder` 与 `StringBuffer` 的公共父类，定义了一些字符串的基本操作，如 `expandCapacity`、`append`、`insert`、`indexOf` 等公共方法。`StringBuffer` 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。`StringBuilder` 并没有对方法进行加同步锁，所以是非线程安全的。

🚩 性能

每次对 `String` 类型进行改变的时候，都会生成一个新的 `String` 对象，然后将指针指向新的 `String` 对象。`StringBuffer` 每次都会对 `StringBuffer` 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 `StringBuilder` 相比使用 `StringBuffer` 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。

🍪 总结

1. 操作少量数据，适用 `String`

2. 单线程操作字符串缓冲区的大量数据：适用`StringBuilder`

3. 多线程下字符串缓存区下操作大量数据：适用`StringBuffer`  

#### Java9 为何要将 String 底层实现有 char[] 改成 byte[] ?
新版的 String 其实支持两个编码方案： Latin-1 和 UTF-16。如果字符串中包含的汉字没有超过 Latin-1 可表示范围内的字符，那就会使用 Latin-1 作为编码方案。Latin-1 编码方案下，byte 占一个字节(8 位)，char 占用 2 个字节（16），byte 相较 char 节省一半的内存空间

JDK 官方就说了绝大部分字符串对象只包含 Latin-1 可表示的字符。

#### 字符串拼接用“+” 还是 StringBuilder?
java 语言本身不支持运算符的重载，"+" 和 "+=" 是专门为 String 重载过的运算符。

每次使用 "+" 拼接字符串时，实际上是创建了一个新的 `StringBuilder` 对象，调用 `append` 拼接完之后在调用 `toString` 得到一个 `String`对象。所以在大量数据进行字符串的拼接时，应该用 `StringBuilder`，避免多次创建 `StringBuilder` 对象，节省内存。

#### String #equals() 和 Object #equals() 有何区别？
`String` 中的 `equals` 方法是被重写过的，比较的是 `String` 字符串的值是否相等。 `Object` 的 `equals` 方法是比较的对象的内存地址。

#### 字符串常量池？
字符串常量池 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域（**用来存储 `String`对象的引用**），主要目的是为了避免字符串的重复创建。

#### String s1 = new String("abc");这句话创建了几个字符串对象？
会创建 1 或 2 个字符串对象

1. 如果字符串常量池没有字符串对象"abc"的**引用**，那么就会在堆里创建两个对象，将一个对象的引用放入 字符串常量池，将这个引用作为参数传入构造方法 new String(String str) 中

2. 如果字符串常量池存在字符串对象"abc"的**引用**，那么直接把这个引用当作参数传入构造方法 new String(String str) 中在堆中创建一个对象

#### intern() 方法有什么用?
`String.intern()` 是一个 native（本地）方法，其作用是将指定的字符串对象的引用保存在字符串常量池中，可以简单分为两种情况：

1. 如果字符串常量池中保存了对应的字符串对象的**引用**，就直接返回该引用。

2. 如果字符串常量池中没有保存对应的字符串对象的**引用**，那就在常量池中创建一个指向该字符串对象的引用并返回(即将这个字符串对象的引用放入常量池中并返回这个引用)。

#### String 类型的变量和常量做“+”运算时发生了什么？
- 当 `+` 两侧都为常量时（在编译期就可以确定），虚拟机就会做“常量折叠”的优化，如
```
String c = "str" + "ing"; // 等同于 String c = "string"; 常量池中的对象

final String a = "str";
final String b = "ing";
String ab = a + b; // 依然等同于 String ab = "string"; 常量池中的对象

System.out.println(ab == c); // true
```
- 当 `+` 两侧有一侧不为常量时，则虚拟机不会优化。
```
final String a = "str";
final String b = getStr();

String c = "string"; // 常量池中的对象
String ab = a + b; // 堆上的对象
System.out.println(c == ab);// false

public static String getStr() {
      return "ing";
}
```

## 异常
#### 两类异常
`Exception` 和 `Error`，都有一个共同祖先 `Throwale` 
- 能够被程序处理的：`Exception`: 可以通过 `catch` 来捕获。该类异常又被分为 受检异常（必须在程序里手动声明，并处理） 和 非受检异常（可以不做处理） 
- 不能被程序处理的：`Error`：不建议用 `catch` 来处理。一般有 java 虚拟机内存溢出，类定义错误等

![](https://javaguide.cn/assets/types-of-exceptions-in-java.75041da9.png)

#### 受检异常 和 非受检异常？
- 受检异常：Java 代码在编译过程中，如果受检查异常没有被`catch`或者`throws`关键字处理的话，就没办法通过编译。除了 `RuntimeException` 及其子类以外，其他`Exception` 都是受检异常
- 不受检查异常 ，Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。`RuntimeException` 及其子类都统称为非受检查异常，常见的有（建议记下来，日常开发中会经常用到）：
   - `NullPointerException`
   - `IllegalAgumentException`
   - `NumberFormatException` 字符串转换数字格式错误
   - `ArrayIndexOutOfBoundsException` 数组下标越界
   - `ClassCastException` 类型转换错误
   - `ArithmeticException` 算术错误
#### Throwable 类常用方法有哪些？
- `String getMessage()` 返回异常发生时的简要描述
- `String toString()` 返回异常发生时的详细信息
- `String getLocalizedMessage()` 返回异常对象的本地化信息。使用 `Throwable` 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 `getMessage()`返回的结果相同
- `void printStackTrace()` 在控制台上打印 Throwable 对象封装的异常信息

#### try-catch-finally
- `try` 块：中的代码，用于捕获异常，其后可接零个或多个 `catch` 块，如果没有 `catch` 块，则必须跟一个 `finally` 块。
- `catch`块 ： 用于处理 `try` 捕获到的异常。
- `finally` 块 ： 无论是否捕获或处理异常，`finally` 块里的语句都会被执行。当在 `try` 块或 `catch` 块中遇到 return 语句时，`finally` 语句块将在方法返回之前被执行。

不建议在 `finally`块中 使用 `return`! 当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return 语句会被忽略。这是因为 try 语句中的 return 返回值会先被暂存在一个本地变量中，当执行到 finally 语句中的 return 之后，这个本地变量的值就变为了 finally 语句中的 return 返回值。

#### finally 中的代码一定会执行吗？
不一定，只要在之前程序被终止（线程死亡，CPU关闭），如`System.exit(1)`，`finally` 中的代码就不会被执行。

#### try-with-resources 代替 try-catch-finally ？
可以，但有适用范围： 实现`java.lang.AutoCloseable`或者 `java.io.Closeable` 的对象(资源)。

关闭资源和 `finally` 块的执行顺序：在 `try-with-resources` 语句中，任何 `catch` 或 `finally` 块在声明的资源关闭后运行

`try-with-resources` 形式：
```
try (Scanner scanner = new Scanner(new File("test.txt"))) {
    while (scanner.hasNext()) {
        System.out.println(scanner.nextLine());
    }
} catch (FileNotFoundException fnfe) {
    fnfe.printStackTrace();
}
```

## I/O 流
#### 什么是序列化和反序列化？
#### 


## 泛型
#### 什么是泛型？
JDK1.5 开始使用**泛**型化参数（即可指定参数的类型为任何一种符合条件的类型），增强代码的可读和复用性。如泛型类 `ArrayList<T>`

#### 泛型的使用方式有哪几种？
- 泛型类
	```
	//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型
	//在实例化泛型类时，必须指定T的具体类型
	public class Generic<T>{

	    private T key;

	    public Generic(T key) {
		this.key = key;
	    }

	    public T getKey(){
		return key;
	    }
	}
	```
 实例化泛型类：
	```
	Generic<Integer> genericInteger = new Generic<Integer>(123456);
	```
- 泛型接口
	```
	public interface Generator<T> {
	    public T method();
	}
	```
  实现泛型接口，但不指定类型：
	  ```
	  class GeneratorImpl<T> implements Generator<T>{
	    @Override
	    public T method() {
		return null;
	    }
	  }
	  ```
  实现泛型接口，指定类型：
	  ```
	  class GeneratorImpl<T> implements Generator<String>{
	    @Override
	    public String method() {
		return "hello";
	    }
	  }
	  ```
- 泛型方法
	```
	public <T> void m(T data){
	    ...
	}
	public <T> T m1(T data){
	    ...
	    return (T)data;
	}
	public static <E> void m2(E e){
	    ...
	} 
	```
注意：静态泛型方法，其泛型不能声明为类的泛型，因为类的泛型参数，只有当创建该类对象时才会传入参数类型，而静态方法先于类的实例存在，所以静态泛型方法泛型不能声明为类的泛型，只能声明自己的类型 `<E>`。

#### 泛型通配符?
有一种很容易导致的错误：会错误地认为 `G<Object>` 是 `G<String>` 的父类。其实在编译期的类型擦除后，它们都是 `G` 类型，不存在继承关系。

那么问题来了，某些方法要实现传入参数的多态，就像非泛型类一样，该如何表示呢？

这时泛型通配符就起作用了：通配符用 `?` 表示。`G<? super String>` 即可同时匹配
`G<Object>` 和 `G<String>`，该通配符对泛型类型做了向下限制，泛型`T`必须是 `String` 及其父类。同样也有向上限制，即 `G<? extends Object>`。而`G<?>`等同于
`G<? extends Object>` 而非 `G<Object>`。

#### 泛型擦除和限制？
1.5 之前没有泛型，如 `ArrayList`的元素类型都为`Object`，1.5起，出现泛型`ArrayList<T>`，为了向以前的代码兼容，推出了泛型的类型擦除机制。

泛型的类型擦除机制，发生在**编译期**，编译器会使用泛型类型信息来编译内容，主要是为了检测编译的代码是否安全合法（如`ArrayList<Integer>`对象中加入一个`String`对象是不合法的），但随后就会将泛型类型信息擦除，而将参数类型换为`Object`。所以泛型只存在于编译时，在运行时不可用。
```
// 编译前
ArrayList<String> list = new ArrayList<>();
list.add("str");
String s = list.get(0);

// 类型擦除后
ArrayList list = new ArrayList();
list.add("str");
String s = (String)list.get(0);
```

🍪 如果泛型类型参数是受限制的，就会将类型替换为该受限制类型。
```
// 编译前
public <E extends Comparable> void method(E e1,E e2){
	//...
}

// 类型擦除后
public void method(Comparable e1,Comparable e2){
	//...
}	
```

🍪 值得注意的是不管泛型类型参数是什么，泛型类都是被它的实例共享的。
```
        ArrayList<String> strings = new ArrayList<>();
        ArrayList<Integer> integers = new ArrayList<>();
        System.out.println(strings instanceof ArrayList); //true
        System.out.println(integers instanceof ArrayList); //true
```

🚩 因为泛型类型参数只存在于编译时，而在运行时被擦除，所以在编写程序时，有如下限制：
- 不能使用 `new T()`
- 不能使用 `new T[]`
- 不能创建 泛型类型的数组 比如`ArrayList<String>[] a = new ArrayList<String>[capacity]`
- 禁止在静态上下文中使用类的泛型参数
- 异常类不能用泛型

## 反射 & 注解
#### 何为反射？其作用？
反射（reflect）被称为框架的灵魂，它可以帮助开发者在程序运行时动态地分析类以及执行类中方法的能力。通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。

#### 反射的应用场景？
Spring/Spring Boot、MyBatis 等等框架中都大量使用了反射机制。
这些框架中也大量使用了**动态代理**，而动态代理的实现也依赖**反射**。
```
public class DebugInvocationHandler implements InvocationHandler {
    /**
     * 代理类中的真实对象
     */
    private final Object target;

    public DebugInvocationHandler(Object target) {
        this.target = target;
    }


    public Object invoke(Object proxy, Method method, Object[] args) throws InvocationTargetException, IllegalAccessException {
        System.out.println("before method " + method.getName());
        Object result = method.invoke(target, args); // 利用反射
        System.out.println("after method " + method.getName());
        return result;
    }
}
``` 
另外，**注解**的实现也用到了反射。比如，在使用 Spring 时，`@Value`注解可以指定属性的值是配置文件中的值，`@Component` 可以将一个类声明为 Spring Bean。这是因为使用反射分析了这些类的注解，得到注解就可以进行相应的操作。

#### 反射的优缺点？
- 优点：让代码更加灵活，为各种框架开箱即用的功能提供了遍历。
- 缺点：增加了安全问题，比如可以利用反射逃避**泛型安全检查（在编译期检查）**，而在运行时没有类型的限制（**由于泛型擦除**）。演示代码见//todo

另一缺点是，性能的下滑，在 //todo 测试中用反射创建对象的效率比正常创建对象的效率低了 10 倍！

#### 获取 Class 对象的四种方式
- 知道具体类的情况下可以使用：
```
Class alunbarClass = TargetObject.class;
```
但是我们一般是不知道具体类的，基本都是通过遍历包下面的类来获取 Class 对象，通过此方式获取 Class 对象不会进行初始化
- 通过 `Class.forName()`传入类的全路径获取：
```
Class alunbarClass1 = Class.forName("cn.javaguide.TargetObject");
```
- 通过对象实例instance.getClass()获取：
```
TargetObject o = new TargetObject();
Class alunbarClass2 = o.getClass();
```
- 通过类加载器xxxClassLoader.loadClass()传入类路径获取:
```
ClassLoader.getSystemClassLoader().loadClass("cn.javaguide.TargetObject");
```

#### 反射的一些基本操作
以下操作，引自 JavaGuide

创建一个我们要使用反射操作的类 TargetObject
```
package cn.javaguide;

public class TargetObject {
    private String value;

    public TargetObject() {
        value = "JavaGuide";
    }

    public void publicMethod(String s) {
        System.out.println("I love " + s);
    }

    private void privateMethod() {
        System.out.println("value is " + value);
    }
}
```
使用反射操作这个类的方法以及参数
```
package cn.javaguide;

import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

public class Main {
    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException, NoSuchFieldException {
        /**
         * 获取 TargetObject 类的 Class 对象并且创建 TargetObject 类实例
         */
        Class<?> targetClass = Class.forName("cn.javaguide.TargetObject");
        TargetObject targetObject = (TargetObject) targetClass.newInstance();
        /**
         * 获取 TargetObject 类中定义的所有方法
         */
        Method[] methods = targetClass.getDeclaredMethods();
        for (Method method : methods) {
            System.out.println(method.getName());
        }

        /**
         * 获取指定方法并调用
         */
        Method publicMethod = targetClass.getDeclaredMethod("publicMethod",
                String.class);

        publicMethod.invoke(targetObject, "JavaGuide");

        /**
         * 获取指定参数并对参数进行修改
         */
        Field field = targetClass.getDeclaredField("value");
        //为了对类中的参数进行修改我们取消安全检查
        field.setAccessible(true);
        field.set(targetObject, "JavaGuide");

        /**
         * 调用 private 方法
         */
        Method privateMethod = targetClass.getDeclaredMethod("privateMethod");
        //为了调用private方法我们取消安全检查
        privateMethod.setAccessible(true);
        privateMethod.invoke(targetObject);
    }
}
```
输出内容：
```
publicMethod
privateMethod
I love JavaGuide
value is JavaGuide
```

#### 注解


