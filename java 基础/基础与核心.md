## Java 语言基础&常识
#### Java 语言的特点？
- 面向对象（封装，继承和多态）
- 可移植 （基于JVM）
- 编译和解释共存（基于JVM中的JIT和解释器）
- 支持多线程（os）
- 支持网络编程（net）
- 可靠，稳定

#### JVM vs JRE vs JDK
🚩 JVM 是执行 java 字节码的虚拟机，是实现 java 可移植的关键。有很多实现版本，平常使用的是 Hotpot VM

🚩 JRE 是 java 运行环境，可运行已被编译的 java程序。包含了 JVM、java类库、java 命令和其他基础构件

🚩 JDK 是 java 开发工具，是功能齐全的 Java SDK。包含了 JRE 和编译器及其他工具。能够创建和编译 Java 程序

#### 什么是字节码？Java 采用字节码有什么好处？
能被 JVM 理解的代码即为字节码。字节码不面向特殊的机器，而只面向 JVM，采用字节码帮助 java 实现平台移植性。

java 程序运行如下图

![f1](https://javaguide.cn/assets/java%E7%A8%8B%E5%BA%8F%E8%BD%AC%E5%8F%98%E4%B8%BA%E6%9C%BA%E5%99%A8%E4%BB%A3%E7%A0%81%E7%9A%84%E8%BF%87%E7%A8%8B.3af43aee.png)

 JIT（just-in-time compilation） 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。

#### 为什么说 Java 是编译和解释共存的语言？
- 编译型语言：将程序语言一次编译成机器码，全部执行，执行速度快，开发效率慢。如 C，C++
- 解释型语言：将程序逐行解释成机器码并执行，执行速度慢，开发效率快。若 JavaScript，python
![f2](https://javaguide.cn/assets/%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80.9908e5e6.png)
JVM 类加载器首先加载**字节码文件**，然后通过**解释器逐行**解释执行，故称为编译和解释共存，这种方式的执行速度会相对比较慢

#### OracleJDK vs OpenJDK
OracleJDK 属于商用 JDK，而 OpenJDK 只是OracleJDK 的一个分支

#### Java 和 C++ 区别
- Java 只支持单重继承，C++支持多重继承，Java支持实现多接口
- Java 实现内存区域自动管理————垃圾回收机制，不用自己销毁对象，而C++只能手动释放内存
- Java 不支持通过指针直接访问内存，而C++ 支持
- C++ 支持操作符的重载，而 Java 不支持


## Java 基本语法
#### 字符型常量和字符串型常量的区别？
- 形式：字符型常量用单引号引起来的一个字符，而字符串型常量是用双引号引起来的 0~多个字符集合
- 含义：字符相当于一个整型值（ASCII），可以参与表达式运算，字符串常量代表一个地址值
- 大小：字符常量只占 2 个字节

#### 标识符 和 关键字 的区别？
为大量的类，变量，方法取名，简单来，说标识符就是一个名字。有一些标识符 Java 已经赋予其特殊意义
，这些就是关键字，如 protected,private,public,long,final等。

#### 自增自减运算符
**自增**和**赋值**注意顺序！

## 基本数据类型
#### 几种基本类型
🚩 数字类型: `int-4` `byte-1` `short-2` `double-8` `float-4` `long-8`

🚩 字符类型 `char-1`

🚩 布尔类型 `boolean-1Bit`

![image](https://user-images.githubusercontent.com/59677595/174266627-06c1d2be-11fb-4a24-84c7-a578ba199e53.png)

八种基本类型都有其包装类

#### 基本类与包装类的区别？
- 成员变量包装类不赋初值就为 null，而成员基本类型变量都有其默认值
- 包装类可用于泛型，基本类型不可
- 位置：包装类几乎所有实例始终被放在 堆 中
- 包装类占用空间较大

**为什么说是几乎所有对象实例呢？** 这是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存

#### 包装类型的缓存机制？
提升性能。对于 `Integer` `Byte` `Short` `Long` 这四种类型，默认（static）创建了数值 -128~127 的相应类型的缓存数据。`Character` 创建了数值在[0,127]范围的缓存数据,`Boolean`直接返回 `True`or`false`。

测试缓存：
```
Integer i1 = 40;
Integer i2 = new Integer(40);
System.out.println(i1==i2);  //false
```
输出为 false，是因为第一条代码发生装箱，也就是说等价于`Integer i1=Integer.valueOf(40)` 。因此，`i1` 直接使用的是缓存中的对象。而`Integer i2 = new Integer(40)`会直接创建新的对象。
因此，答案是 false

#### 自动装箱与拆箱
```
Integer i = 10; //装箱，等价于 Integer i = Integer.valueOf(10);
int n = i; //拆箱， 等价于 int n = i.intValue();
```
注意：如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。

## 方法
#### 静态方法为什么不能调用非静态成员？
结合 JVM 相关知识：时空角度
- 归属：静态方法属于类，再类加载的时候就给其分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化后才能通过实例对象访问。
- 先后：静态方法早于非静态成员存在，此时调用不存在的非静态成员是非法操作

#### 静态方法与实例方法有什么不同？
- 调用方式：静态方法通过`类名.方法名`，实例方法通过`对象.方法名`，调用静态方法不需要创建对象。
- 访问限制：静态方法只能访问静态成员，不能访问实例成员

#### 方法的重载与重写
- 重载：同样（同样的方法名）的方法根据输入的数据（参数）不同做出不同的处理
- 重写：基于继承，子类继承父类的相同方法，但做出一个有别父类的响应，就须重写（覆盖）方法，
如果父类用 `private/final/static` 修饰 方法时，子类无法重写。被`static`修饰的方法能够被再次声明。构造方法无法被重写。

![image](https://user-images.githubusercontent.com/59677595/174264178-bfa3d051-a7b4-4c70-a65f-6a4f19c7aa5a.png)

🚩 方法的重写要遵循“两同两小一大”（以下内容摘录自《疯狂 Java 讲义》，issue#892 ）：
- “两同”即方法名相同、形参列表相同；
- “两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；
- “一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。

#### 可变长参数？
可变长参数允许传递给方法不定数个参数，实质上被当作数组来处理了，在方法重载的时候优先匹配固定参数的。
```
public static void method(String... args){
  ...
}
//优先匹配
public static void method(String arg1,String arg2){
  ...
}
```


## 面向对象基础
#### 面向对象与面向过程的区别 ？
解决问题的方式不同：
- 面向过程：将解决问题的过程拆解为一个个方法，通过一个个方法的执行来解决问题
- 面向对象：对问题建模，先抽象出对象，然后用对象执行方法的方式解决问题

面向对象的程序，更易复用，维护和拓展。

#### 成员变量和局部变量的区别 ？
- 语法形式：成员变量是属于类的，局部变量是属于方法的。成员变量可以被 `public`,`private`,`static`等修饰符修饰，而局部变量不能。但是 `final` 可以用来修饰 成员变量和局部变量
- 存储方式: 在没有 `static` 修饰的情况下，成员变量是属于对象实例的，位于 堆 heap 中，局部变量属于方法，位于栈中
- 生存时间: 成员变量随对象的创建而存在，而局部变量随方法的调用而生成，方法调用结束而消亡
- 默认值: 成员变量有默认值，而局部变量没有

#### 创建一个对象用什么运算符？对象实体与对象引用有何不同？
new 运算符。对象实体是是对象的实例，是指储存在堆中的数据。而对象引用只是指向对象实例，只是地址值，它被存放在栈中。

#### 对象的相等和引用相等的区别
- 对象相等：比较的是内存中存放的内容是否相等
- 引用相等比较指向的内存地址是否相等

#### 类的构造方法是什么？它的作用？如果一个类没有声明构造方法，该程序能正常执行吗 ?
类的构造方法是一种特殊的方法，主要作用是完成对象的初始化工作。若没有声明构造方法，也可执行，因为自动有默认的不带参数的构造方法，如果手动声明无参或有参构造方法，将不会自动配置无参构造方法。

#### 构造方法有哪些特点？是否可被 override?
- 名字与类名相同。
- 没有返回值，不可用 void 声明
- 生成类的对象是自动执行，不需要调用

构造方法不能 override，但是可以重载。

#### 面向对象三大特征
三大特征：封装，继承，多态

**封装**：

封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象内部的信息。但是可以提供一些可被外界访问的方法来操作属性。

**继承**：

继承是使用已存在的类作为基础建立新类的技术（扩展技术），新类定义新的数据或功能，也可以使用父类的功能。值得说的是，子类必须继承父类的全部，不能选择性的继承。

- 子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，**只是拥有**。
- 子类可以有自己的属性和方法
- 子类可以用自己的方式重写 父类的方法

**多态** ：

顾名思义，表示一个对象具有多个状态，具体表现为父类的引用指向子类的实例。

特点：
- 对象类型与引用类型之间具有继承/实现的关系
- 引用类型变量发出的方法调用到底是哪个类中的方法，必须到程序运行期间才能确定
- **多态不能调用只有子类存在而父类不存在的方法**
- 如果子类重写了父类方法，真正在执行的是子类覆盖的方法，如果没有覆盖，将执行父类的方法

#### 接口和抽象类有什么共同点和区别？

🚩 共同点：
- 都不能直接实例化
- 都有抽象方法
- 都可以由默认实现的方法（java8 `default`）

🚩 不同点：
- 接口主要用于对类的行为进行约束，实现某个接口就具有了对应的行为，而抽象类主要用于代码复用，强调所属关系
- 一个类只能继承一个抽象类，但可以实现多个接口
- 接口中的成员变量只能用 `public static final`修饰，不能被修改且必须由初始值，而抽象类的成员变量默认为 `default`，可在子类被**重新定义**和赋值。

#### 深拷贝和浅拷贝的区别？什么是引用拷贝？
- 浅拷贝：在对象发生浅拷贝时，会在堆上创建新的对象（这不同于引用拷贝），如果这个对象类型成员变量有引用类型的话，浅拷贝只会直接复制内部对象的引用地址值，也就是说，拷贝对象和源对象共同拥有一个内部对象
- 深拷贝：在深拷贝时，会创建在堆中一个内部对象的副本，并用新的引用指向拷贝对象的内部对象，**即全部复制整个对象，包括内部对象**

实现方式：
- 浅拷贝：直接调用父类`Object`的`clone()`
- 深拷贝：需要实现 `Cloneable`接口，重写`clone()`，将内部对象也调用`clone()`复制一下即可

引用拷贝：就是两个不同的引用指向同一个对象

![image](https://user-images.githubusercontent.com/59677595/174634938-678625be-b4da-431e-8e3c-ebcdb16285af.png)

## Java 常见类

#### Object
这是一个特殊的类，是所有的父类。它主要提供了以下 11 个方法：
```
/**
 * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。
 */
public final native Class<?> getClass()
/**
 * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。
 */
public native int hashCode()
/**
 * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。
 */
public boolean equals(Object obj)
/**
 * naitive 方法，用于创建并返回当前对象的一份拷贝。
 */
protected native Object clone() throws CloneNotSupportedException
/**
 * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。
 */
public String toString()
/**
 * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。
 */
public final native void notify()
/**
 * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。
 */
public final native void notifyAll()
/**
 * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。
 */
public final native void wait(long timeout) throws InterruptedException
/**
 * 多了 nanos 参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 毫秒。。
 */
public final void wait(long timeout, int nanos) throws InterruptedException
/**
 * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念
 */
public final void wait() throws InterruptedException
/**
 * 实例被垃圾回收器回收的时候触发的操作
 */
protected void finalize() throws Throwable { }
```

**== 和 equals() 的区别**

- ``==`` 对于基本类型：比较的是值；对于引用类型：比较的是引用指向的地址值（对象的内存地址）。

> 因为 Java 只有值传递，所以，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。

- `equals()` 只能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。`equals()` 存在于 `Object`类中，而 `Object` 类是所有类的直接或间接的父类，因此所有的类都有 `equals()` 方法

`Object`类`equals()`方法：
```
public boolean equals(Object obj) {
     return (this == obj);
}
```
`equals()`两种使用情况：
- 类没有重写 `equals()`方法，等价于 "=="
- 有重写`equals()`方法，一般用来比较两个对象的属性是否相等
- `String` 的`equals()`方法又被重写：比较的是值。

`String`类`equals()`方法：

```
public boolean equals(Object anObject) {
    if (this == anObject) {
        return true;
    }
    if (anObject instanceof String) {
        String anotherString = (String)anObject;
        int n = value.length;
        if (n == anotherString.value.length) {
            char v1[] = value;
            char v2[] = anotherString.value;
            int i = 0;
            while (n-- != 0) {
                if (v1[i] != v2[i])
                    return false;
                i++;
            }
            return true;
        }
    }
    return false;
}
```

注：当创建 `String` 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 `String` 对象。

**hashCode()有什么用？**

获取 哈希码（int 整数，也称散列码），该方法是本地方法，由 C/C++ 实现，根据对象的内存地址值来计算得出。

**哈希码有什么作用？为什么要有哈希码？**

哈希码作用是确定该对象在哈希表中的索引位置，有助于提高哈希表键值对数据结构 存储和查找效率。
- 存储方面：存储不重复的元素（需要借助 hashCode() 和 equals() 来判断）
- 查询方面：最快能将效率提到 O(1),通过计算元素的哈希码得到键，快速检索出其对应的值（ contains() ） 

🚩 看看 HashSet 如何检查重复？—— 说明为什么有 hashCode

> 当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashCode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashCode 值作比较，如果没有相符的 hashCode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashCode 值的对象，这时会调用 equals() 方法来检查 hashCode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。

你会发现：`equals()` 和 `hashCode()` 都能判断对象是否相等，但是它们有所不同：
- 两个对象的`hashCode`值相等，这两个对象不一定相等（哈希冲突）
- 如果两个对象的`hashCode`值相等并且`equals()`方法也返回 `true`，我们才认为这两个对象相等。
- 如果两个对象的`hashCode`值不相等，我们就可以直接认为这两个对象不相等。

**为什么重写 equals 方法时，必须重写 hashCode 方法？**

⚠️ 注意：这是在你要将对象加入散列集中的前提下，必须做的事

在这个前提下，要**规定**两个对象相等，必须重写这两个方法（使得两个对象相等时，必须使 `hashCode`值相等并且`equals()`方法也返回 `true`）。如果只重写了 `equals()`，那么存在`equals()`判断相等的两个对象，它们 `hashCode` 不相等。那么散列集中出现 按**规定**相等的重复对象！（ 👀 具体测试代码见 ）

## String
#### String && StringBuilder && StringBuffer 的区别
🚩 可变性:

- String 是不可变的，原因是：它的内部实现
```
public final class String implements java.io.Serializable, Comparable<String>, CharSequence {
    private final char value[];
	//...
}
```
1. char 数组被 `private` 和 `final`修饰，且没有对外提供对该数组操作的方法

2. String 被声明为 `final`，不能被继承，避免了子类破环 String 不可变

- StringBuilder 与 StringBuffer 都继承于 AbstractStringBuilder ，在AbstractStringBuilder 中也是使用字符数组保存字符串，不过没有使用 final 和 private 关键字修饰，最关键的是这个 AbstractStringBuilder 类还提供了很多修改字符串的方法比如 append 方法
```
abstract class AbstractStringBuilder implements Appendable, CharSequence {
    char[] value;
    public AbstractStringBuilder append(String str) {
        if (str == null)
            return appendNull();
        int len = str.length();
        ensureCapacityInternal(count + len);
        str.getChars(0, len, value, count);
        count += len;
        return this;
    }
  	//...
}
```

🚩 线程安全性

`String` 中的对象是不可变的，也就可以理解为常量，线程安全。`AbstractStringBuilder` 是 `StringBuilder` 与 `StringBuffer` 的公共父类，定义了一些字符串的基本操作，如 `expandCapacity`、`append`、`insert`、`indexOf` 等公共方法。`StringBuffer` 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。`StringBuilder` 并没有对方法进行加同步锁，所以是非线程安全的。

🚩 性能

每次对 `String` 类型进行改变的时候，都会生成一个新的 `String` 对象，然后将指针指向新的 `String` 对象。`StringBuffer` 每次都会对 `StringBuffer` 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 `StringBuilder` 相比使用 `StringBuffer` 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。

🍪 总结

1. 操作少量数据，适用 `String`

2. 单线程操作字符串缓冲区的大量数据：适用`StringBuilder`

3. 多线程下字符串缓存区下操作大量数据：适用`StringBuffer`  

#### Java9 为何要将 String 底层实现有 char[] 改成 byte[] ?
新版的 String 其实支持两个编码方案： Latin-1 和 UTF-16。如果字符串中包含的汉字没有超过 Latin-1 可表示范围内的字符，那就会使用 Latin-1 作为编码方案。Latin-1 编码方案下，byte 占一个字节(8 位)，char 占用 2 个字节（16），byte 相较 char 节省一半的内存空间

JDK 官方就说了绝大部分字符串对象只包含 Latin-1 可表示的字符。

#### 字符串拼接用“+” 还是 StringBuilder?
java 语言本身不支持运算符的重载，"+" 和 "+=" 是专门为 String 重载过的运算符。

每次使用 "+" 拼接字符串时，实际上是创建了一个新的 `StringBuilder` 对象，调用 `append` 拼接完之后在调用 `toString` 得到一个 `String`对象。所以在大量数据进行字符串的拼接时，应该用 `StringBuilder`，避免多次创建 `StringBuilder` 对象，节省内存。

#### String #equals() 和 Object #equals() 有何区别？
`String` 中的 `equals` 方法是被重写过的，比较的是 `String` 字符串的值是否相等。 `Object` 的 `equals` 方法是比较的对象的内存地址。

#### 字符串常量池？
字符串常量池 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域（**用来存储 `String`对象的引用**），主要目的是为了避免字符串的重复创建。

#### String s1 = new String("abc");这句话创建了几个字符串对象？
会创建 1 或 2 个字符串对象

1. 如果字符串常量池没有字符串对象"abc"的**引用**，那么就会在堆里创建两个对象，将一个对象的引用放入 字符串常量池，将这个引用作为参数传入构造方法 new String(String str) 中

2. 如果字符串常量池存在字符串对象"abc"的**引用**，那么直接把这个引用当作参数传入构造方法 new String(String str) 中在堆中创建一个对象

#### intern() 方法有什么用?
`String.intern()` 是一个 native（本地）方法，其作用是将指定的字符串对象的引用保存在字符串常量池中，可以简单分为两种情况：

1. 如果字符串常量池中保存了对应的字符串对象的**引用**，就直接返回该引用。

2. 如果字符串常量池中没有保存对应的字符串对象的**引用**，那就在常量池中创建一个指向该字符串对象的引用并返回(即将这个字符串对象的引用放入常量池中并返回这个引用)。

#### String 类型的变量和常量做“+”运算时发生了什么？
- 当 `+` 两侧都为常量时（在编译期就可以确定），虚拟机就会做“常量折叠”的优化，如
```
String c = "str" + "ing"; // 等同于 String c = "string"; 常量池中的对象

final String a = "str";
final String b = "ing";
String ab = a + b; // 依然等同于 String ab = "string"; 常量池中的对象

System.out.println(ab == c); // true
```
- 当 `+` 两侧有一侧不为常量时，则虚拟机不会优化。
```
final String a = "str";
final String b = getStr();

String c = "string"; // 常量池中的对象
String ab = a + b; // 堆上的对象
System.out.println(c == ab);// false

public static String getStr() {
      return "ing";
}
```


