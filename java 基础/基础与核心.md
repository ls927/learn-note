## Java 语言基础&常识
#### Java 语言的特点？
- 面向对象（封装，继承和多态）
- 可移植 （基于JVM）
- 编译和解释共存（基于JVM中的JIT和解释器）
- 支持多线程（os）
- 支持网络编程（net）
- 可靠，稳定

#### JVM vs JRE vs JDK
🚩 JVM 是执行 java 字节码的虚拟机，是实现 java 可移植的关键。有很多实现版本，平常使用的是 Hotpot VM

🚩 JRE 是 java 运行环境，可运行已被编译的 java程序。包含了 JVM、java类库、java 命令和其他基础构件

🚩 JDK 是 java 开发工具，是功能齐全的 Java SDK。包含了 JRE 和编译器及其他工具。能够创建和编译 Java 程序

#### 什么是字节码？Java 采用字节码有什么好处？
能被 JVM 理解的代码即为字节码。字节码不面向特殊的机器，而只面向 JVM，采用字节码帮助 java 实现平台移植性。

java 程序运行如下图

![f1](https://javaguide.cn/assets/java%E7%A8%8B%E5%BA%8F%E8%BD%AC%E5%8F%98%E4%B8%BA%E6%9C%BA%E5%99%A8%E4%BB%A3%E7%A0%81%E7%9A%84%E8%BF%87%E7%A8%8B.3af43aee.png)

 JIT（just-in-time compilation） 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。

#### 为什么说 Java 是编译和解释共存的语言？
- 编译型语言：将程序语言一次编译成机器码，全部执行，执行速度快，开发效率慢。如 C，C++
- 解释型语言：将程序逐行解释成机器码并执行，执行速度慢，开发效率快。若 JavaScript，python
![f2](https://javaguide.cn/assets/%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80.9908e5e6.png)
JVM 类加载器首先加载**字节码文件**，然后通过**解释器逐行**解释执行，故称为编译和解释共存，这种方式的执行速度会相对比较慢

#### OracleJDK vs OpenJDK
OracleJDK 属于商用 JDK，而 OpenJDK 只是OracleJDK 的一个分支

#### Java 和 C++ 区别
- Java 只支持单重继承，C++支持多重继承，Java支持实现多接口
- Java 实现内存区域自动管理————垃圾回收机制，不用自己销毁对象，而C++只能手动释放内存
- Java 不支持通过指针直接访问内存，而C++ 支持
- C++ 支持操作符的重载，而 Java 不支持


## Java 基本语法
#### 字符型常量和字符串型常量的区别？
- 形式：字符型常量用单引号引起来的一个字符，而字符串型常量是用双引号引起来的 0~多个字符集合
- 含义：字符相当于一个整型值（ASCII），可以参与表达式运算，字符串常量代表一个地址值
- 大小：字符常量只占 2 个字节

#### 标识符 和 关键字 的区别？
为大量的类，变量，方法取名，简单来，说标识符就是一个名字。有一些标识符 Java 已经赋予其特殊意义
，这些就是关键字，如 protected,private,public,long,final等。

#### 自增自减运算符
**自增**和**赋值**注意顺序！

## 基本数据类型
#### 几种基本类型
🚩 数字类型: `int-4` `byte-1` `short-2` `double-8` `float-4` `long-8`

🚩 字符类型 `char-1`

🚩 布尔类型 `boolean-1Bit`

![image](https://user-images.githubusercontent.com/59677595/174266627-06c1d2be-11fb-4a24-84c7-a578ba199e53.png)

八种基本类型都有其包装类

#### 基本类与包装类的区别？
- 成员变量包装类不赋初值就为 null，而成员基本类型变量都有其默认值
- 包装类可用于泛型，基本类型不可
- 位置：包装类几乎所有实例始终被放在 堆 中
- 包装类占用空间较大

**为什么说是几乎所有对象实例呢？** 这是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存

#### 包装类型的缓存机制？
提升性能。对于 `Integer` `Byte` `Short` `Long` 这四种类型，默认（static）创建了数值 -128~127 的相应类型的缓存数据。`Character` 创建了数值在[0,127]范围的缓存数据,`Boolean`直接返回 `True`or`false`。

测试缓存：
```
Integer i1 = 40;
Integer i2 = new Integer(40);
System.out.println(i1==i2);  //false
```
输出为 false，是因为第一条代码发生装箱，也就是说等价于`Integer i1=Integer.valueOf(40)` 。因此，`i1` 直接使用的是缓存中的对象。而`Integer i2 = new Integer(40)`会直接创建新的对象。
因此，答案是 false

#### 自动装箱与拆箱
```
Integer i = 10; //装箱，等价于 Integer i = Integer.valueOf(10);
int n = i; //拆箱， 等价于 int n = i.intValue();
```
注意：如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。

## 方法
#### 静态方法为什么不能调用非静态成员？
结合 JVM 相关知识：时空角度
- 归属：静态方法属于类，再类加载的时候就给其分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化后才能通过实例对象访问。
- 先后：静态方法早于非静态成员存在，此时调用不存在的非静态成员是非法操作

#### 静态方法与实例方法有什么不同？
- 调用方式：静态方法通过`类名.方法名`，实例方法通过`对象.方法名`，调用静态方法不需要创建对象。
- 访问限制：静态方法只能访问静态成员，不能访问实例成员

#### 方法的重载与重写
- 重载：同样（同样的方法名）的方法根据输入的数据（参数）不同做出不同的处理
- 重写：基于继承，子类继承父类的相同方法，但做出一个有别父类的响应，就须重写（覆盖）方法，
如果父类用 `private/final/static` 修饰 方法时，子类无法重写。被`static`修饰的方法能够被再次声明。构造方法无法被重写。

![image](https://user-images.githubusercontent.com/59677595/174264178-bfa3d051-a7b4-4c70-a65f-6a4f19c7aa5a.png)

🚩 方法的重写要遵循“两同两小一大”（以下内容摘录自《疯狂 Java 讲义》，issue#892 ）：
- “两同”即方法名相同、形参列表相同；
- “两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；
- “一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。

#### 可变长参数？
可变长参数允许传递给方法不定数个参数，实质上被当作数组来处理了，在方法重载的时候优先匹配固定参数的。
```
public static void method(String... args){
  ...
}
//优先匹配
public static void method(String arg1,String arg2){
  ...
}
```


